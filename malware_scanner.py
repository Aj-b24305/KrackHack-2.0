import yara
import os
import json
import warnings
from flask import Flask

def load_yara_rules(index_file_path):
    """Loads YARA rules from the specified file path."""
    try:
        rules = yara.compile(filepath=index_file_path)
        return rules
    except Exception as e:
        print(f"Error compiling {index_file_path}: {e}")
        return None

# Load YARA rules (this should be done *once* when the app starts)
index_file_path = 'rules/index.yar'  # Update this to the path of index.yar
yara_rules = load_yara_rules(index_file_path)

# Added this check so the app doesn't crash if the YARA rules are not found
if yara_rules is None:
    print("Failed to load YARA rules. The application will not function correctly.")

def scan_file(file_path):
    """Scans a file for malware using the provided YARA rules."""
    try:
        # Suppress RuntimeWarnings
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", RuntimeWarning)
            matches = yara_rules.match(file_path)

        # Define benign matches to ignore
        benign_matches = {
            "anti_dbg",
            "win_files_operation",
            "IsPE64",
            "IsPE32",
            "IsWindowsGUI",
            "HasDebugData",
            "HasDigitalSignature",
            "Borland",
            "HasOverlay",
            "Borland_Cpp",
            "borland_cpp",
            "Borland_Cpp_for_Win32_1995",
            "Borland_Cpp_additional",
            "Microsoft_Cisual_Cpp_80",
            "VC8_Microsoft_Corporation",
            "Microsoft_Visual_Cpp_8",
            "Big_Numbers0",
            "Big_Numbers2",
            "Big_Numbers3",
            "Big_Numbers5",  # Added missing comma here
            "Microsoft_Visual_C_Basic_NET",
            "Microsoft_Visual_Studio_NET_additional",
            "Microsoft_Visual_C_v70_Basic_NET",
            "NET_executable_",
            "NET_executable",
            "HasRichSignature",
            "Microsoft_Visual_Cpp_80_DLL",
            "Big_Numbers1",
            "IsConsole",
            "MinGW_1",
            "multiple_versions"
        }

        # Filter out benign matches
        filtered_matches = [match for match in matches if match.rule not in benign_matches]

        num_matches = len(filtered_matches)
        scan_result = "MALICIOUS" if num_matches > 5 else "CLEAN"

        return {
            "filename": os.path.basename(file_path),
            "matches": [match.rule for match in filtered_matches],  # Just the rule names
            "scan_status": "completed",
            "error_message": None,
            "scan_result": scan_result  # "MALICIOUS" or "CLEAN"
        }
    except Exception as e:
        return {
            "filename": os.path.basename(file_path),
            "matches": [],
            "scan_status": "error",
            "error_message": str(e),
            "scan_result": "ERROR"  # Indicate an error occurred
        }

if __name__ == "__main__":
    # Example usage (for testing)
    if os.path.isfile("test_file.txt"):
        scan_results = scan_file("test_file.txt")
    else:
        with open("test_file.txt", "wb") as f:
            f.write(b"This file contains EICAR test string and suspicious_api_call.")
        scan_results = scan_file("test_file.txt")
    print(json.dumps(scan_results, indent=4))

